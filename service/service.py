from flask import Flask
from flask_restful import abort, Api, fields, marshal_with, reqparse, Resource
from datetime import datetime
from pytz import utc
from models import NotificationModel
from http_status import HttpStatus



class NotificationManager():
    """Persisting notification model instances using an in-memory dictionary"""
    last_id = 0

    def __init__(self):
        self.notifications = {}

    
    def insert_notification(self, notification):
        """Receives a recently created NotificationModel instance as an argument and stores in dictionary"""
        # class attributes/variables can be accessed in regular instance methods using __class__ syntax
        self.__class__.last_id += 1
        # assign notif id to class variable increment
        notification.id = self.__class__.last_id
        # store notification in dictionary 
        self.notifications[self.__class__.last_id] = notification


    def get_notification(self, id):
        """Returns a NotificationModel instance through id as an argument"""
        return self.notifications[id]

    
    def delete_notification(self, id):
        """"Deletes a NotificationModel instance through id as an argument"""
        del self.notifications[id]


# dictionary to control data we want to Flask to render in our responses
notification_fields = {
    'id': fields.Integer,
    'uri': fields.Url('notification_endpoint'),  # using a specific endpoint name instead of a relative URI which
    # will be generated by default
    'message': fields.String,
    'ttl': fields.Integer,
    #'creation_date': fields.datetime,
    'notification_category': fields.String,
    'displayed_times': fields.Integer,
    'displayed_once': fields.Boolean,
    }

notification_manager = NotificationManager()


# note to self: a subclass of flask_restful.Resource represents a RESTful resource so one class has to be for a Notification 
# resource and another for a Notification collection

class Notification(Resource):
    """A RESTful Resource for a Notification resource"""

    def abort_if_notification_not_found(self, id):
        if id not in notification_manager.notifications:
            abort(
                HttpStatus.not_found_404.value, 
                message=f'Notification {id} does not exist'
            )

# note to self: anytime marshal_with is used a 200 ok HttpStatus should be expected
    
    @marshal_with(notification_fields)
    def get(self, id):
        """Retriving a single notification resource"""
        self.abort_if_notification_not_found(id)
        return notification_manager.get_notification(id)

    
    # no marshal_with on decorator delete because you are deleting the particular notification instance from the dictionary repo
    # and not accessing any data from the notification_fields
    def delete(self, id):
        self.abort_if_notification_not_found(id)
        notification_manager.delete_notification(id)
        return '', HttpStatus.no_content_204.value


    @marshal_with(notification_fields)
    def patch(self, id):
        """In patch, resource is partially modified and not updated entirely so still id has to be retrived and certain fields
        will then be changed"""

        self.abort_if_notification_not_found(id)
        notification = notification_manager.get_notification(id)
        # reqparse is flask's own in-built commandline module
        # also helps in type checking
        parser = reqparse.RequestParser()
        parser.add_argument('message', type=str)
        parser.add_argument('ttl', type=int)
        parser.add_argument('displayed_once', type=bool)
        parser.add_argument('displayed_times', type=int)
        # reqparse's parse_args() method returns a dictionary
        args = parser.parse_args()
        print(args)
        # since patch is modifying already existing data the fields should not be empty
        if 'message' in args and args['message'] is not None:
            notification.message = args['message']
        if 'ttl' in args and args['ttl'] is not None:
            notification.ttl = args['ttl']
        if 'displayed_once' in args and args['displayed_once'] is not None:
            notification.displayed_once = args['displayed_once']
        if 'displayed_times' in args and args['displayed_times'] is not None:
            notification.displayed_times = args['displayed_times']
        
        return notification


class NotificationList(Resource):

    @marshal_with(notification_fields)
    def get(self):
        """Returns notification collection. Returns a list of all notification instances"""
        return [v for v in notification_manager.notifications.values()]


    @marshal_with(notification_fields)
    def post(self):
        parser = reqparse.RequestParser()
        parser.add_argument('message', type=str, required=True, help='Message cannot be blank')
        parser.add_argument('ttl', type=int, required=True, help='Time to live cannot be blank')
        parser.add_argument('notification_category', type=str, required=True, help='Notification category')
        args = parser.parse_args()
        notification = NotificationModel(
            message = args['message'],
            ttl = args['ttl'],
           # creation_date = datetime.now(utc),
            notification_category = args['notification_category']
        )
        notification_manager.insert_notification(notification)
        return notification, HttpStatus.created_201.value


app = Flask(__name__)
service = Api(app)
# configuring resource routing and endpoints
# for collection
service.add_resource(NotificationList, '/service/notifications/')
# for single notif resource
service.add_resource(Notification, '/service/notifications/<int:id>', endpoint='notification_endpoint')

if __name__ == "__main__":
    app.run(host='0.0.0.0', debug=True) 
# for Ipv6 configurations, ::, for Ipv6 configurations, 0.0.0.0

    




    